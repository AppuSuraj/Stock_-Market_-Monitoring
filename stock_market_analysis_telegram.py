# -*- coding: utf-8 -*-
"""Stock_Market_Analysis_Telegram.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EcMD6f1hV8TgEGzBRbayjNd_rM7kWs7N
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Improved stock notifier: fetches richer info per ticker and formats a concise,
useful Telegram-friendly plain-text message. Sends charts and top gainers/losers.

Dependencies:
  - yfinance
  - pandas
  - requests
  - matplotlib
"""
import os
import sys
import logging
from datetime import datetime, timezone, timedelta
import math

import requests
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt

# Set the backend for matplotlib to 'Agg' for non-GUI environments
plt.switch_backend('Agg')

# Environment variables for Telegram Bot API
# You need to set these environment variables before running the script
# For example, in your terminal:
# export TELEGRAM_BOT_TOKEN='YOUR_BOT_TOKEN'
# export TELEGRAM_CHAT_ID='YOUR_CHAT_ID'
# Replace with your actual token and chat ID

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

# Default tickers (change as needed)
# Add more tickers here to fetch data and generate charts for them
TICKERS = [
    "TATAMOTORS.NS",  # Tata Motors - Significant player in Indian EV passenger and commercial vehicles
    "M&M.NS",         # Mahindra & Mahindra - Also developing EVs
    "MARUTI.NS",      # Maruti Suzuki India - Entering the EV space
    "EXIDEIND.NS",    # Exide Industries - Involved in battery manufacturing (including for EVs)
    "GRAPHITE.NS",    # Graphite India - Involved in materials used in batteries
    "HEG.NS",         # HEG Ltd - Also involved in graphite electrodes
    "POWERGRID.NS"    # Power Grid Corporation of India - National power transmission grid, relevant for EV charging infrastructure (indirect)
]

# Helpers
def _fmt(x):
    """Formats numbers for display."""
    try:
        if x is None:
            return "—"
        if isinstance(x, int):
            return f"{x:,}"
        if isinstance(x, float):
            s = f"{x:,.2f}"
            if s.endswith(".00"):
                s = s[:-3]
            return s
        return str(x)
    except Exception:
        return str(x)


def _percent(curr, prev):
    """Calculates percentage change."""
    try:
        if curr is None or prev is None or prev == 0:
            return None
        return (curr - prev) / prev * 100.0
    except Exception:
        return None


def _trend_marker(pct):
    """Returns an emoji indicating the trend based on percentage change."""
    if pct is None:
        return ""
    if pct >= 5:
        return "🚀"
    if pct >= 1:
        return "🔼"
    if pct <= -5:
        return "📉"
    if pct <= -1:
        return "🔽"
    return "➖"


def fetch_stock_data(tickers):
    """
    Fetch richer stock details for each ticker using yfinance.
    Returns list of dicts with useful fields for formatting and historical data.
    """
    results = []
    for ticker in tickers:
        logging.info("Fetching %s", ticker)
        try:
            t = yf.Ticker(ticker)
            info = {}
            try:
                info = t.info or {}
            except Exception:
                logging.debug("Could not fetch .info for %s", ticker)

            # Basic fields: prefer info, fallback to history
            current = info.get("regularMarketPrice")
            prev_close = info.get("previousClose") or info.get("regularMarketPreviousClose")

            day_high = info.get("dayHigh")
            day_low = info.get("dayLow")
            w52h = info.get("fiftyTwoWeekHigh") or info.get("52WeekHigh")
            w52l = info.get("fiftyTwoWeekLow") or info.get("52WeekLow")
            volume = info.get("volume")
            avg_vol = info.get("averageVolume") or info.get("averageDailyVolume10Day") or info.get("averageVolume10days")

            market_cap = info.get("marketCap")
            pe = info.get("trailingPE") or info.get("forwardPE") or info.get("pe")
            div = info.get("dividendYield")

            sma50 = info.get("fiftyDayAverage") or info.get("50DayAverage")
            sma200 = info.get("twoHundredDayAverage") or info.get("200DayAverage")

            name = info.get("shortName") or info.get("longName") or ticker

            # Fetch history for all tickers for potential plotting and data completeness
            hist = None
            try:
                hist = t.history(period="365d")
                if not isinstance(hist, pd.DataFrame) or hist.empty:
                    hist = None
            except Exception:
                logging.debug("Could not fetch history for %s", ticker)


            if current is None and hist is not None:
                try:
                    current = float(hist["Close"].iloc[-1])
                except Exception:
                    current = None
            if prev_close is None and hist is not None and len(hist) >= 2:
                try:
                    prev_close = float(hist["Close"].iloc[-2])
                except Exception:
                    prev_close = None
            if (day_high is None or day_low is None) and hist is not None:
                try:
                    day_high = float(hist["High"].iloc[-1])
                    day_low = float(hist["Low"].iloc[-1])
                except Exception:
                    pass
            if volume is None and hist is not None:
                try:
                    volume = int(hist["Volume"].iloc[-1])
                except Exception:
                    pass

            # Compute SMA if missing and history available
            if (sma50 is None or sma200 is None) and hist is not None:
                try:
                    sma50 = float(hist["Close"].rolling(window=50).mean().iloc[-1]) if len(hist) >= 50 else sma50
                    sma200 = float(hist["Close"].rolling(window=200).mean().iloc[-1]) if len(hist) >= 200 else sma200
                except Exception:
                    pass

            stock = {
                "symbol": ticker,
                "name": name,
                "current": float(current) if current is not None else None,
                "prev_close": float(prev_close) if prev_close is not None else None,
                "day_high": float(day_high) if day_high is not None else None,
                "day_low": float(day_low) if day_low is not None else None,
                "week52_high": float(w52h) if w52h is not None else None,
                "week52_low": float(w52l) if w52l is not None else None,
                "volume": int(volume) if volume is not None else None,
                "avg_volume": int(avg_vol) if avg_vol is not None else None,
                "market_cap": int(market_cap) if market_cap is not None else None,
                "pe": float(pe) if pe is not None else None,
                "dividend_yield": float(div) if div is not None else None,
                "sma50": float(sma50) if sma50 is not None else None,
                "sma200": float(sma200) if sma200 is not None else None,
                "url": f"https://finance.yahoo.com/quote/{ticker}",
                "history": hist # Store history for potential plotting outside this function
            }
            results.append(stock)

        except Exception:
            logging.exception("Error fetching %s", ticker)
    return results

def generate_and_save_plots(stocks):
    """
    Generates price and volume charts for each stock with available history
    and saves them as a single PNG file with subplots arranged in 2 columns.
    Returns a list of paths to the saved image files.
    """
    saved_image_paths = []
    valid_stocks = [stock for stock in stocks if stock.get("history") is not None and not stock.get("history").empty and not stock.get("history").tail(30).empty]

    if not valid_stocks:
        logging.warning("No valid stock history available to generate plots.")
        return saved_image_paths

    num_tickers = len(valid_stocks)
    num_rows = math.ceil(num_tickers / 2) * 2 # Ensure enough rows for price and volume for each ticker in 2 columns
    fig, axes = plt.subplots(num_rows, 2, figsize=(12, 4 * num_rows)) # 2 columns

    # Flatten axes array for easier indexing if there's more than one row
    if num_rows > 0:
        axes = axes.flatten()
    elif num_tickers == 1: # Handle the case of a single ticker
         axes = [axes] # Make axes iterable

    for i, stock in enumerate(valid_stocks):
        ticker = stock.get("symbol")
        hist_last_30_days = stock.get("history").tail(30)

        # Calculate subplot indices for 2 columns
        price_ax_index = i * 2
        volume_ax_index = i * 2 + 1

        # Price Trend subplot
        axes[price_ax_index].plot(hist_last_30_days.index, hist_last_30_days['Close'])
        axes[price_ax_index].set_title(f"{ticker} Price Trend (Last 30 Days)")
        axes[price_ax_index].set_ylabel("Price")
        axes[price_ax_index].tick_params(axis='x', rotation=45)
        axes[price_ax_index].grid(True, linestyle='--', alpha=0.6)

        # Volume subplot
        axes[volume_ax_index].bar(hist_last_30_days.index, hist_last_30_days['Volume'])
        axes[volume_ax_index].set_title(f"{ticker} Trading Volume (Last 30 Days)")
        axes[volume_ax_index].set_ylabel("Volume")
        axes[volume_ax_index].tick_params(axis='x', rotation=45)
        axes[volume_ax_index].grid(True, linestyle='--', alpha=0.6)


    plt.tight_layout()

    # Save the single figure and close it
    filename = "combined_stock_charts.png"
    try:
        plt.savefig(filename)
        saved_image_paths.append(filename)
        logging.info("Saved combined plot as %s", filename)
    except Exception as e:
        logging.error("Failed to save combined plot: %s", e)
    finally:
        plt.close(fig) # Close the figure to free up memory

    return saved_image_paths

def fetch_top_gainers_losers():
    """
    Fetches lists of top 10 gainers and losers.
    Note: yfinance doesn't have a direct API for this,
    so this implementation is a placeholder or would require
    fetching data for a broad market index and calculating changes.
    For this task, we'll use a placeholder implementation based on the
    current TICKERS list for demonstration purposes, as a real-world
    implementation fetching data for thousands of tickers would be slow
    and outside the scope of a simple example.
    A more robust solution would require a different data source API.

    Returns:
        tuple: A tuple containing two lists:
            - list of dicts for top gainers ({'symbol': str, 'percent_change': float})
            - list of dicts for top losers ({'symbol': str, 'percent_change': float})
    """
    logging.info("Attempting to fetch top gainers and losers (using placeholder logic).")

    # In a real scenario, you would use an API call here.
    # Since yfinance doesn't have a direct method for this list,
    # we will simulate this by calculating changes for the predefined TICKERS
    # and sorting them. This is NOT how you'd get *market-wide* top lists.

    try:
        # Fetch data for the predefined tickers to calculate changes
        stocks_for_ranking = fetch_stock_data(TICKERS) # Reuse existing fetch logic

        stock_changes = []
        for stock in stocks_for_ranking:
            pct_change = _percent(stock.get("current"), stock.get("prev_close"))
            if pct_change is not None:
                stock_changes.append({
                    "symbol": stock.get("symbol"),
                    "percent_change": pct_change
                })

        # Sort by percentage change
        stock_changes.sort(key=lambda x: x["percent_change"], reverse=True)

        # Get top 10 gainers and losers from this limited list
        # If the list has fewer than 20 stocks, some might appear in both lists
        # depending on their relative performance.
        top_gainers = stock_changes[:10]
        top_losers = sorted(stock_changes, key=lambda x: x["percent_change"])[:10]


        logging.info("Fetched %d potential gainers and %d potential losers from tracked tickers.", len(top_gainers), len(top_losers))

        return top_gainers, top_losers

    except Exception:
        logging.exception("Error fetching top gainers/losers.")
        return [], [] # Return empty lists on error


def format_message(stocks, top_gainers=None, top_losers=None):
    """
    Build a compact, information-rich plain-text message suitable for Telegram.
    Summary at top, then one-line header per stock + compact details below.
    Includes a note about an accompanying combined chart and lists top gainers/losers.
    """
    if not stocks:
        return "No stock data available."

    now = datetime.now(timezone.utc).astimezone(timezone(timedelta(hours=5, minutes=30)))
    header_time = now.strftime("%Y-%m-%d %H:%M:%S IST")

    lines = []
    lines.append(f"📈 Stock Snapshot • {len(stocks)} tracked • {header_time}")
    lines.append("") # Add blank line for spacing

    # Add a line referencing the combined chart
    lines.append("*(See accompanying combined chart for price and volume trends)*")
    lines.append("") # Add blank line after chart note

    # Add Top Gainers and Losers section
    if top_gainers:
        lines.append("🏆 Top 3 Gainers:")
        for gainer in top_gainers[:3]: # Limit to top 3
            lines.append(f"  {gainer['symbol']} ({gainer['percent_change']:+.2f}%)")
        lines.append("") # Add blank line after gainers
    if top_losers:
        lines.append("💔 Top 3 Losers:")
        for loser in top_losers[:3]: # Limit to top 3
            lines.append(f"  {loser['symbol']} ({loser['percent_change']:+.2f}%)")
        lines.append("") # Add blank line after losers


    for s in stocks:
        sym = s.get("symbol")
        name = s.get("name")
        curr = s.get("current")
        prev = s.get("prev_close")
        pct = _percent(curr, prev)
        trend = _trend_marker(pct)

        # Header line: trend, symbol, current price and % change
        header = f"{trend} {sym} — ₹{_fmt(curr)}" if curr is not None else f"{sym} — price N/A"
        if pct is not None:
            header += f" ({pct:+.2f}%)"
        lines.append(header)

        # Compact detail line with core stats
        parts = []
        parts.append(f"Prev: ₹{_fmt(prev)}" if prev is not None else "Prev: —")
        parts.append(f"Day: ₹{_fmt(s.get('day_low'))}–₹{_fmt(s.get('day_high'))}" if (s.get('day_low') is not None or s.get('day_high') is not None) else "Day: —")
        parts.append(f"52W: ₹{_fmt(s.get('week52_low'))}–₹{_fmt(s.get('week52_high'))}" if (s.get('week52_low') is not None or s.get('week52_high') is not None) else "52W: —")
        parts.append(f"Vol: {_fmt(s.get('volume'))}" if s.get('volume') is not None else "Vol: —")
        if s.get('avg_volume') is not None:
            parts[-1] += f" (Avg {_fmt(s.get('avg_volume'))})"

        # Valuation / indicators
        val = []
        if s.get('market_cap') is not None:
            # friendly cap: show in cr/kk or use human readable
            mc = s.get('market_cap')
            if mc >= 1_00_00_00_000:  # >1 lakh crore -> show in trillions not likely for NSE; basic formatting
                val.append(f"Mkt cap: {_fmt(mc)}")
            else:
                val.append(f"Mkt cap: {_fmt(mc)}")
        if s.get('pe') is not None:
            val.append(f"P/E: {_fmt(s.get('pe'))}")
        if s.get('dividend_yield') is not None:
            try:
                dv = float(s.get('dividend_yield'))
                if abs(dv) < 1:
                    dv = dv * 100.0
                val.append(f"Div: {_fmt(dv)}%")
            except Exception:
                val.append(f"Div: {_fmt(s.get('dividend_yield'))}")
        if s.get('sma50') is not None and s.get('sma200') is not None:
            pos = "SMA50>SMA200" if s.get('sma50') > s.get('sma200') else "SMA50<SMA200"
            val.append(pos)
        elif s.get('sma50') is not None:
            val.append(f"SMA50: {_fmt(s.get('sma50'))}")

        # Append stats and valuation as separate lines to keep header concise
        lines.append(" • ".join(parts))
        if val:
            lines.append(" • ".join(val))

        # optional chart/url line
        if s.get('url'):
            lines.append(f"Chart: {s.get('url')}")

        lines.append("")  # blank between stocks

    # Footer notes
    lines.append("Notes:")
    lines.append("- Data from Yahoo Finance via yfinance")
    lines.append("- This is informational only; not financial advice")


    return "\n".join(lines)


def _split_chunks(text, size=3900):
    """Split large messages into Telegram-safe chunks trying to respect paragraph breaks."""
    if len(text) <= size:
        return [text]
    parts = []
    remaining = text
    while remaining:
        if len(remaining) <= size:
            parts.append(remaining)
            break
        idx = remaining.rfind("\n\n", 0, size)
        if idx == -1:
            idx = remaining.rfind("\n", 0, size)
        if idx == -1:
            idx = size
        parts.append(remaining[:idx].rstrip())
        remaining = remaining[idx:].lstrip()
    return parts


def send_telegram(token, chat_id, text, image_paths=None):
    """
    Send text and optional images to Telegram.
    Sends the first image with text as caption, then remaining images and text in chunks.
    Handles a single combined plot image correctly.
    """
    last_resp = None
    image_paths = image_paths or []

    # Send the first image with text as caption if available
    if image_paths and os.path.exists(image_paths[0]):
        try:
            with open(image_paths[0], 'rb') as image_file:
                # Telegram caption limit is 1024 characters.
                # Split the text if it's longer than the caption limit.
                caption = text[:1024]
                remaining_text = text[1024:].lstrip()

                files = {'photo': image_file}
                payload = {"chat_id": chat_id, "caption": caption, "disable_web_page_preview": "true"}
                url = f"https://api.telegram.org/bot{token}/sendPhoto"
                r = requests.post(url, data=payload, files=files, timeout=15)
                r.raise_for_status()
                last_resp = r.json()
                logging.info("Sent photo to Telegram: %s", image_paths[0])

                # Send remaining text if any
                if remaining_text:
                    logging.info("Sending remaining text in chunks.")
                    text_parts = _split_chunks(remaining_text, size=3900)
                    send_url = f"https://api.telegram.org/bot{token}/sendMessage"
                    for part in text_parts:
                         msg_payload = {"chat_id": chat_id, "text": part, "disable_web_page_preview": "true"}
                         r = requests.post(send_url, data=msg_payload, timeout=15)
                         r.raise_for_status()
                         last_resp = r.json()

        except FileNotFoundError:
            logging.error("Image file not found at %s. Falling back to sending text only.", image_paths[0])
            # Fallback to sending just the text
            url = f"https://api.telegram.org/bot{token}/sendMessage"
            parts = _split_chunks(text, size=3900)
            for part in parts:
                payload = {"chat_id": chat_id, "text": part, "disable_web_page_preview": "true"}
                r = requests.post(url, data=payload, timeout=15)
                r.raise_for_status()
                last_resp = r.json()
        except Exception:
            logging.exception("Error sending photo to Telegram. Falling back to text.")
            # Fallback to sending just the text
            url = f"https://api.telegram.org/bot{token}/sendMessage"
            parts = _split_chunks(text, size=3900)
            for part in parts:
                payload = {"chat_id": chat_id, "text": part, "disable_web_page_preview": "true"}
                r = requests.post(url, data=payload, timeout=15)
                r.raise_for_status()
                last_resp = r.json()

        # Send subsequent images (this block will be skipped if only one image)
        for img_path in image_paths[1:]:
             if os.path.exists(img_path):
                 try:
                     with open(img_path, 'rb') as image_file:
                        files = {'photo': image_file}
                        # No caption for subsequent images to keep it simple
                        payload = {"chat_id": chat_id, "disable_web_page_preview": "true"}
                        url = f"https://api.telegram.org/bot{token}/sendPhoto"
                        r = requests.post(url, data=payload, files=files, timeout=15)
                        r.raise_for_status()
                        last_resp = r.json()
                        logging.info("Sent subsequent photo to Telegram: %s", img_path)
                 except FileNotFoundError:
                    logging.error("Subsequent image file not found at %s", img_path)
                 except Exception:
                    logging.exception("Error sending subsequent photo %s", img_path)
             else:
                  logging.warning("Subsequent image file not found at %s", img_path)


    else:
        # Send only text if no image path is provided or first file not found
        logging.info("No image paths provided or first image file not found. Sending text only.")
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        parts = _split_chunks(text, size=3900)
        for part in parts:
            payload = {"chat_id": chat_id, "text": part, "disable_web_page_preview": "true"}
            r = requests.post(url, data=payload, timeout=15)
            r.raise_for_status()
            last_resp = r.json()

    return last_resp


def main():
    token = os.environ.get("TELEGRAM_BOT_TOKEN")
    chat_id = os.environ.get("TELEGRAM_CHAT_ID")
    if not token or not chat_id:
        logging.error("TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID must be set as environment variables.")
        sys.exit(1)

    stocks = fetch_stock_data(TICKERS)
    if not stocks:
        logging.error("No stock data fetched; aborting.")
        sys.exit(1)

    # Call the function to get top gainers and losers
    top_gainers, top_losers = fetch_top_gainers_losers()

    # Generate and save the combined plot
    generated_image_paths = generate_and_save_plots(stocks)

    # Format the message, including top gainers/losers
    # Pass the fetched top_gainers and top_losers to format_message
    message = format_message(stocks, top_gainers=top_gainers, top_losers=top_losers)
    logging.info("Message length: %d characters", len(message))
    logging.info("Message preview:\n%s", message[:1000])

    try:
        # Pass the list of image paths (should be just one for the combined plot) to send_telegram
        res = send_telegram(token, chat_id, message, image_paths=generated_image_paths)
        logging.info("Telegram response: %s", res)
    except Exception:
        logging.exception("Failed to send Telegram message")
        sys.exit(1)

    # Clean up generated image files
    for img_path in generated_image_paths:
        if os.path.exists(img_path):
            try:
                os.remove(img_path)
                logging.info("Removed temporary image file: %s", img_path)
            except Exception as e:
                logging.error("Failed to remove temporary image file %s: %s", img_path, e)


if __name__ == "__main__":
    main()